#pragma once
#include <cstddef>
#include <fstream>
#include <iostream>
#include <format>
#include <regex>

#include "xxhash/xxhash.h"

#include "utils/PathUtils.hpp"
#include "parsing/metadata/ClassInfo.hpp"
#include "parsing/CursorLocation.hpp"

class Utils {
public:
	static uint64_t GetHashForFile(const fs::path& path) {
        std::ifstream file(path, std::ios::binary);
        XXH64_state_t* state = XXH64_createState();
        XXH64_reset(state, 0);

        std::vector<char> buffer(4096);
        while (file.read(buffer.data(), buffer.size()) || file.gcount() > 0)
            XXH64_update(state, buffer.data(), file.gcount());

        uint64_t hash = XXH64_digest(state);
        XXH64_freeState(state);
        return hash;
	}

    static void CreateCPPFileFor(const fs::path& path, const std::vector<fs::path>& headers) {
        std::stringstream str;
		str << "// This file was generated by Amethyst Symbol Generator.\n\n";
		for (auto& inc : headers)
            str << std::format("#include \"{}\"\n", inc.generic_string());
        std::ofstream out(path);
        out << str.str();
		out.close();
    }

    static void Benchmark(const std::function<void()>& func, const std::string& name) {
        auto start = std::chrono::high_resolution_clock::now();
        func();
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
        std::cout << std::format("[Benchmark] {} took {} ms\n", name, duration);
	}

    static bool HasSymbolGenerationMarker(const fs::path& path) {
        std::ifstream file(path);
        if (!file)
            return false;
        std::string content((std::istreambuf_iterator<char>(file)),
            std::istreambuf_iterator<char>());

        std::regex marker(R"(\/\/\/\s*@symgen)");
        if (!std::regex_search(content, marker))
            return false;
        return true;
    }

    static bool IsFileInIncludes(const fs::path& file, const fs::path& input, const std::vector<fs::path>& includes) {
        auto definedInRelative = fs::relative(file, input);
        for (auto& inc : includes) {
            if (inc == definedInRelative)
                return true;
        }
		return false;
    }
};