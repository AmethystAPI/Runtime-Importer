#include <iostream>
#include <unordered_set>
#include <stack>
#include "clang-c/Index.h"
#include "CLI11.hpp"
#include "Json.hpp"
#include "Utils.hpp"
#include "xxhash/xxhash.h"
#include "PathUtils.hpp"
#include "parsing/HeaderParser.hpp"
#include <algorithm>
#include "parsing/CommentParser.hpp"

using namespace nlohmann;
namespace fs = std::filesystem;

struct SymbolGeneratorContext {
    fs::path InputDirectory;
	fs::path GeneratedDirectory;
	std::vector<fs::path> Filters;
	std::vector<std::string> ClangArgs;
} Context;

void PrintClassInfo(ClassInfo* cls, int indent = 0) {
    if (!cls) return;

    std::string indentation(indent * 2, ' ');
    std::cout << indentation << "Class: " << cls->Name
        << " | Virtual: " << (cls->HasAtLeastOneVirtualFunction() ? "yes" : "no")
        << " | Base: " << (cls->HasNoBases() ? "yes" : "no")
        << " | Multi-Inheritance: " << (cls->DoesMultiInheritance() ? "yes" : "no")
		<< " | LastOwnVirtualIndex: " << cls->NextVirtualIndex
        << "\n";

    if (!cls->Functions.empty()) {
        for (auto* func : cls->Functions) {
            std::cout << indentation << "  - Function: " << func->MangledName
                << " | Virtual: " << (func->IsVirtual ? "yes" : "no")
                << " | VTableIndex: " << func->VirtualIndex
                << " | VTableTarget: " << (func->VirtualTableTarget.has_value() ? *func->VirtualTableTarget : "invalid_vtable");
            if (func->OverrideOfName.has_value())
                std::cout << " | Overrides: " << func->OverrideOfName.value();
            std::cout << "\n";
        }
    }

    //// recursively print direct bases
    //for (auto* base : cls->mDirectBaseInfos) {
    //    PrintClassInfo(base, indent + 1);
    //}
}

int main(int argc, char** argv) {
	CLI::App app{ "Amethyst Symbol Generator v0.0.1" };

	// Add options
	app.add_option("--input-directory", Context.InputDirectory, "The input directory to look for header files.");
	app.add_option("--generated-directory", Context.GeneratedDirectory, "The output directory to write generated files to.");
    app.add_option("--filters", Context.Filters, "Only process headers that have the relative path starting with those filters.")->expected(1, -1);
	app.allow_extras();
	app.set_help_all_flag("--help-all", "Expand all help");

	// Parse command line arguments
	CLI11_PARSE(app, argc, argv);

	// Collect remaining arguments as clang args
    Context.ClangArgs = app.remaining();

    Context.InputDirectory = Context.InputDirectory.generic_string();

    fs::path checksumFile = "checksums.json";
    fs::path checksumPath = Context.GeneratedDirectory / checksumFile;

	// Load existing checksums if present
	std::unordered_map<std::string, uint64_t> oldHashes;
    if (fs::exists(checksumPath))
    {
        std::ifstream in(checksumPath);
        json j;
        in >> j;
        for (auto& [key, val] : j.items())
            oldHashes[key] = val.get<uint64_t>();
    }

    // Collect all headers
    std::vector<fs::path> headers;
    if (Context.Filters.empty()) {
        for (auto& p : fs::recursive_directory_iterator(Context.InputDirectory)) {
            if (p.path().extension() == ".h" || p.path().extension() == ".hpp")
                headers.push_back(fs::relative(p.path(), Context.InputDirectory));
        }
    }
    else {
        for (auto& filter : Context.Filters) {
            for (auto& p : fs::recursive_directory_iterator(Context.InputDirectory / filter)) {
                if (p.path().extension() == ".h" || p.path().extension() == ".hpp")
                    headers.push_back(fs::relative(p.path(), Context.InputDirectory));
            }
        }
    }

    std::vector<std::string> tuIncludes;

    std::unordered_map<std::string, uint64_t> newHashes;
    for (auto& h : headers)
    {
        uint64_t hHash = Utils::GetHashForFile(Context.InputDirectory / h);
        newHashes[h.string()] = hHash;

        // Decide if we need to reparse
        if (true)//oldHashes.find(h.string()) == oldHashes.end() || oldHashes[h.string()] != hHash)
        {
            std::cout << "[Changed/Added] " << h << "\n";
			tuIncludes.push_back(h.string());
        }
    }

    // Save updated checksums
    json out;
    for (auto& [path, h] : newHashes)
        out[path] = h;

    std::ofstream o(checksumPath);
    o << out.dump(4);
	o.close();

	std::ofstream tuFile(Context.GeneratedDirectory / "generated.cpp");
	tuFile << "// This file was generated by Amethyst Symbol Generator.\n\n";
    for (auto& inc : tuIncludes)
		tuFile << "#include \"" << inc << "\"\n";
    tuFile.close();
	std::cout << "Generated translation unit: " << (Context.GeneratedDirectory / "generated.cpp") << "\n";

	// Set up Clang translation unit
    std::vector<const char*> clangArgCStrs;
    for (auto& arg : Context.ClangArgs)
		clangArgCStrs.push_back(arg.c_str());
	auto tuFilePath = (Context.GeneratedDirectory / "generated.cpp").string();

    auto start = std::chrono::high_resolution_clock::now();
	
	// Create the translation unit parser
	HeaderParser parser(
        tuFilePath,
        clangArgCStrs,
        CXTranslationUnit_DetailedPreprocessingRecord |
        CXTranslationUnit_SkipFunctionBodies, 
        ParsingData{
            .mInputDirectory = Context.InputDirectory
        },
        Context.Filters);

    // Visit and sort everything
	parser.VisitAll();
	parser.SortAllClassesTopologically();
    parser.SortAllFunctionsTopologically();

	// Resolve relationships
	parser.ResolveAllClassBases();
    parser.ResolveAllClassFunctions();
	parser.ResolveAllFunctionOverrides();

	// Resolve virtual stuff
    parser.ResolveBaseClassVirtualFunctionsIndex();
    parser.ResolveNewVirtualFunctionIndices();
    parser.ResolveAllFunctionOverridesIndices();

    for (auto& [className, classInfo] : parser.mClasses) {
		PrintClassInfo(&classInfo);
    }

    for (auto& [className, classInfo] : parser.mClasses) {
        if (classInfo.Comment.has_value()) {
            ParsingContext ctx{
                .mClass = &classInfo
            };
            auto parsedComments = CommentParser::ParseComment(*classInfo.Comment, ctx);
            for (auto& parsedComment : parsedComments) {
                if (std::holds_alternative<VirtualPointerComment>(parsedComment)) {
                    auto& parsed = std::get<VirtualPointerComment>(parsedComment);
                    std::cout << std::hex << parsed.mAddress << " = " << parsed.mForVtable << "\n";
                }
            }

            for (auto* func : classInfo.Functions) {
                ParsingContext ctx{
                    .mClass = &classInfo,
                    .mFunction = func
                };

                auto parsedComments = CommentParser::ParseComment(*(func->Comment), ctx);
                for (auto& parsedComment : parsedComments) {
                    if (std::holds_alternative<VirtualIndexComment>(parsedComment)) {
                        auto& parsed = std::get<VirtualIndexComment>(parsedComment);
                        std::cout << parsed.mIndex << "\n";
                    }
                }
            }
        }
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> diff = end - start;
    std::cout << "Parsing + visiting took " << diff.count() << " seconds\n";

    // Pause before exit
	std::cout << "Press Enter to exit...";
	std::cin.get();
}