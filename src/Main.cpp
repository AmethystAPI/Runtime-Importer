#include <iostream>
#include <unordered_set>
#include <stack>
#include "clang-c/Index.h"
#include "CLI11.hpp"
#include "Json.hpp"
#include "Utils.hpp"
#include "xxhash/xxhash.h"
#include "PathUtils.hpp"
#include "SymbolGenerator.hpp"
#include "parsing/HeaderParser.hpp"
#include <algorithm>

using namespace nlohmann;
namespace fs = std::filesystem;

struct SymbolGeneratorContext {
    fs::path InputDirectory;
	fs::path GeneratedDirectory;
	std::vector<fs::path> Filters;
	std::vector<std::string> ClangArgs;
} Context;

void PrintClass(ClassInfo& info, int indent) {
    std::string indentStr(indent * 2, ' ');
    std::cout << indentStr << "Class: '" << info.mName << "' is virtual: " << (info.isVirtual ? "true" : "false") << "\n";
    for (auto& func : info.mAllFunctionInfos) {
        std::cout << indentStr << "  Function: '" << func->mMangledName << "' is virtual: " << (func->isVirtual ? "true" : "false") << "\n";
	}
    if (!info.mDirectBaseInfos.empty()) {
        for (auto* baseInfo : info.mDirectBaseInfos) {
            PrintClass(*baseInfo, indent + 4);
        }
	}
}

int main(int argc, char** argv) {
	CLI::App app{ "Amethyst Symbol Generator v0.0.1" };

	// Add options
	app.add_option("--input-directory", Context.InputDirectory, "The input directory to look for header files.");
	app.add_option("--generated-directory", Context.GeneratedDirectory, "The output directory to write generated files to.");
    app.add_option("--filters", Context.Filters, "Only process headers that have the relative path starting with those filters.")->expected(1, -1);
	app.allow_extras();
	app.set_help_all_flag("--help-all", "Expand all help");

	// Parse command line arguments
	CLI11_PARSE(app, argc, argv);

	// Collect remaining arguments as clang args
    Context.ClangArgs = app.remaining();

    Context.InputDirectory = Context.InputDirectory.generic_string();

    fs::path checksumFile = "checksums.json";
    fs::path checksumPath = Context.GeneratedDirectory / checksumFile;

	// Load existing checksums if present
	std::unordered_map<std::string, uint64_t> oldHashes;
    if (fs::exists(checksumPath))
    {
        std::ifstream in(checksumPath);
        json j;
        in >> j;
        for (auto& [key, val] : j.items())
            oldHashes[key] = val.get<uint64_t>();
    }

    // Collect all headers
    std::vector<fs::path> headers;
    if (Context.Filters.empty()) {
        for (auto& p : fs::recursive_directory_iterator(Context.InputDirectory)) {
            if (p.path().extension() == ".h" || p.path().extension() == ".hpp")
                headers.push_back(fs::relative(p.path(), Context.InputDirectory));
        }
    }
    else {
        for (auto& filter : Context.Filters) {
            for (auto& p : fs::recursive_directory_iterator(Context.InputDirectory / filter)) {
                if (p.path().extension() == ".h" || p.path().extension() == ".hpp")
                    headers.push_back(fs::relative(p.path(), Context.InputDirectory));
            }
        }
    }

    std::vector<std::string> tuIncludes;

    std::unordered_map<std::string, uint64_t> newHashes;
    for (auto& h : headers)
    {
        uint64_t hHash = Utils::GetHashForFile(Context.InputDirectory / h);
        newHashes[h.string()] = hHash;

        // Decide if we need to reparse
        if (true)//oldHashes.find(h.string()) == oldHashes.end() || oldHashes[h.string()] != hHash)
        {
            std::cout << "[Changed/Added] " << h << "\n";
			tuIncludes.push_back(h.string());
        }
    }

    for (auto& [oldPath, oldHash] : oldHashes) {
        if (newHashes.find(oldPath) == newHashes.end()) {
            std::cout << "[Deleted] " << oldPath << "\n";
			SymbolGenerator::DeleteSymbolsFor(Context.GeneratedDirectory / "symbols", oldPath);
        }
    }

    // Save updated checksums
    json out;
    for (auto& [path, h] : newHashes)
        out[path] = h;

    std::ofstream o(checksumPath);
    o << out.dump(4);
	o.close();

	std::ofstream tuFile(Context.GeneratedDirectory / "generated.cpp");
	tuFile << "// This file was generated by Amethyst Symbol Generator.\n\n";
    for (auto& inc : tuIncludes)
		tuFile << "#include \"" << inc << "\"\n";
    tuFile.close();
	std::cout << "Generated translation unit: " << (Context.GeneratedDirectory / "generated.cpp") << "\n";

	// Set up Clang index
	CXIndex index = clang_createIndex(0, 0);
    if (!index) {
        std::cerr << "Failed to create Clang index.\n";
        return 1;
	}

	// Set up Clang translation unit
    std::vector<const char*> clangArgCStrs;
    for (auto& arg : Context.ClangArgs)
		clangArgCStrs.push_back(arg.c_str());
	auto tuFilePath = (Context.GeneratedDirectory / "generated.cpp").string();

    auto start = std::chrono::high_resolution_clock::now();
	
	// Create the translation unit parser
	HeaderParser parser(
        tuFilePath,
        clangArgCStrs,
        CXTranslationUnit_DetailedPreprocessingRecord |
        CXTranslationUnit_SkipFunctionBodies, 
        ParsingData{
            .mInputDirectory = Context.InputDirectory
        },
        Context.Filters);

    // Visit everything
	parser.VisitAll();
	parser.ResolveAllClassBases();
    parser.ResolveAllClassFunctions();

    for (auto& [className, classInfo] : parser.mClasses) {
		PrintClass(classInfo, 0);
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> diff = end - start;
    std::cout << "Parsing + visiting took " << diff.count() << " seconds\n";

    // Pause before exit
	std::cout << "Press Enter to exit...";
	std::cin.get();
}