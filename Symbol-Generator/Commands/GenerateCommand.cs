using Amethyst.SymbolGenerator.Diagnostics;
using Amethyst.SymbolGenerator.Parsing;
using CliFx;
using CliFx.Attributes;
using CliFx.Infrastructure;
using Microsoft.VisualBasic.FileIO;
using ClangSharp.Interop;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Amethyst.SymbolGenerator.Extensions;
using Amethyst.SymbolGenerator.Tracking;
using System.Diagnostics;

namespace Amethyst.SymbolGenerator.Commands
{
    [Command("generate", Description = "Generates symbol files based on the provided configuration.")]
    public class GenerateCommand : ICommand
    {
        [CommandOption("input", 'i', Description = "Path to the input directory containing header files.", IsRequired = true)]
        public DirectoryInfo Input { get; set; } = null!;

        [CommandOption("output", 'o', Description = "Path to the output directory where symbol files will be generated.", IsRequired = true)]
        public DirectoryInfo Output { get; set; } = null!;

        [CommandOption("filters", 'f', Description = "List of filters to apply when generating symbols.")]
        public IReadOnlyList<string> Filters { get; set; } = null!;

        [CommandOption("c-args")]
        public IReadOnlyList<string> CompilerArguments { get; set; } = [];

        public ValueTask ExecuteAsync(IConsole console)
        {
            ArgumentNullException.ThrowIfNull(Input);
            ArgumentNullException.ThrowIfNull(Output);
            if (Input.Exists is false)
                throw new DirectoryNotFoundException($"Input directory '{Input.FullName}' does not exist.");
            
            // Ensure output directory exists
            Directory.CreateDirectory(Output.FullName);

            Stopwatch stopwatch = Stopwatch.StartNew();

            // Track changes in header files
            FileTracker headerTracker = new(
                inputDirectory: Input,
                checksumFile: new FileInfo(Path.Combine(Output.FullName, "file_checksums.json")),
                searchPatterns: ["*.h", "*.hpp", "*.hh", "*.hxx"],
                filters: [.. Filters]
            );
            FileChange[] changes = [.. headerTracker.TrackChanges()];

            stopwatch.Stop();
            Logger.Info($"File tracking completed in {stopwatch.ElapsedMilliseconds} ms.");

            // Separate changes into added/modified and deleted
            FileChange[] addedOrModified = [.. changes
                .Where(c => c.ChangeType == ChangeType.Added || c.ChangeType == ChangeType.Modified)];
            FileChange[] deleted = [.. changes
                .Where(c => c.ChangeType == ChangeType.Deleted)];

            // Prepare list of includes for added or modified files
            List<string> includes = [];
            foreach (var file in addedOrModified)
            {
                includes.Add(Path.GetRelativePath(Input.FullName, file.FilePath));
            }

            // Prepare .cpp file for parsing
            string cppContents = @$"// This file was generated by Amethyst Symbol Generator. {Environment.NewLine}";
            foreach (var include in includes)
            {
                cppContents += @$"#include ""{include.NormalizeSlashes()}"" {Environment.NewLine}";
            }
            string cppFilePath = Path.Combine(Output.FullName, "Generated.cpp");
            File.WriteAllText(cppFilePath, cppContents);

            stopwatch.Restart();

            // Parse the generated .cpp file
            ASTVisitor visitor = new(
                inputFile: cppFilePath,
                inputDirectory: Input.FullName,
                arguments: CompilerArguments.Select(a => a.TrimStart('\'').TrimEnd('\''))
            );

            // Handle diagnostics
            if (visitor.PrintErrors())
            {
                Logger.Error("Parsing failed due to errors.");
                return default;
            }

            foreach (var classInfo in visitor.GetClasses())
            {
                Logger.Info($"Found class: {classInfo.FullName} {(classInfo.DirectBaseClasses.Length > 0 ? ":" : "")} {string.Join(", ", classInfo.DirectBaseClasses.Select(c => c.FullName))}");
            }

            stopwatch.Stop();
            Logger.Info($"Parsing completed in {stopwatch.ElapsedMilliseconds} ms.");

            return default;
        }
    }
}
